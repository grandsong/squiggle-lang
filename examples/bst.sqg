let {console} = global;

def foldRight(xs, z, f)
    def g(acc, x, _, _)
        f(x, acc)
    end;
    xs.slice().reverse().reduce(g, z)
end;

def Node(data, left, right)
    {type: "Branch", data, left, right}
end;

let Tip = {type: "Tip"};

def leaf(x)
    Node(x, Tip, Tip)
end;

# This actually doesn't end up looking much better with pattern matching since
# we need to make the "less-than" check on the data.
def bstAdd(n, d)
    if n.type == "Tip" then
        leaf(d)
    elseif n.type == "Branch" then
        if d < n.data then
            Node(n.data, bstAdd(n.left, d), n.right)
        else
            Node(n.data, n.left, bstAdd(n.right, d))
        end
    else
        error "not a node"
    end
end;

def inOrder(node)
    match node
    case {type: "Tip"} then
        []
    case {type: "Branch", left, right, data} then
        inOrder(left) ++ [data] ++ inOrder(right)
    end
end;

let root = foldRight(
    [4, 2, 1, 3, 6, 5, 7],
    Tip,
    fn(x, node) bstAdd(node, x)
);

console.log(inOrder(root));
